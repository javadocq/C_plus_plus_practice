### Bit, Byte, Hex

- Hexadecimal(Hex, 16진수)
  - 16진수 2개로 1 byte를 보기 쉽게 표현 <- Hex 사용 이유
  - Hex 표현임을 알리기 위해 앞에 0x를 붙임 (다른 의미는 없다)

ex:
bit 표현 (1byte)
1010 1011

16진수
0x A(1010)B(1011)

10진수
171

### Memory

- 메모리는 읽고 쓸 수 있는 바이트의 집합
  - 메모리에는 다양한 종류가 있으나 여기서는 RAM을 지정
  - 칸이 나눠진 커다란 메모장이라고 생각. 근데 Hex만 사용
    -> 실제로는 0,1 binary로 저장되지만, 불편하니 Hex로 표현
- 각 바이트에는 번호가 붙어있고, 이를 "주소"라고 부름
  - 주소 또한 컴퓨터이기 때문에 Hex로 표현

ex:

[0x0A] 0x 00 00 00 00 //각 1바이트씩 할당
[] 0x 00 00 00 01
[] 0x 00 00 00 02
[] 0x 00 00 00 03

- 우리 환경에서, 정수를 저장할 때 타입에 따라 아래와 같은 용량의 바이트를 사용하도록 되어 있다
  - Char : 1바이트
  - Short : 2바이트
  - Int : 4바이트

- 10이라는 값을 저장할 때
  - Char : 0x0A로 저장
  - Short : 0x00 0A로 저장
  - Int : 0x00 00 00 0A로 저장

Int의 경우

[0A] 0x 00 00 00 00
[00] 0x 00 00 00 01
[00] 0x 00 00 00 02
[00] 0x 00 00 00 03

### 디버깅

디버깅을 하고 조사식에 &변수를 추가해서 메모리 주소를 확인해보면 다음과 같다.

&a = 0x000000016fdfe74f
&b = 0x000000016fdfe74c
&c = 0x000000016fdfe748

c는 4바이트를 먹는 걸 알 수 있다.
근데 왜 &a-&b가 3바이트를 먹냐?? short는 2바이트인데
이거는 맥북 특성상 4바이트나 8바이트 단위로 끊는 걸 좋아하기 떄문에
이런 메모리 정렬 현상 떄문이다.

코드에서 선언 순서를 바꾸면 또 제대로 나올 것이다.

```
#include <iostream>

int main() {
    int c = 10;
    short b = 10;
    char a = 10;
    char d = 10;
}
```

&d = 0x000000016fdfe748
&a = 0x000000016fdfe749
&b = 0x000000016fdfe74a
&c = 0x000000016fdfe74c

여기서 팁은 메모리 패딩 낭비를 줄이기 위해 큰 자료형부터 선언을 하는 것이다.

### Variable

- 따라서 변수란...
  - 메모리의 주소에 붙이는 이름!
  - 변수를 만들면, 메모리에 변수를 위한 공간(바이트)이 확보된다.
    - 공간의 크기(몇칸)는 변수의 타입에 따라 결정
  - 변수에 값을 대입하면, 해당 공간에 값이 기록됨
  - 변수를 만든다 -> 변수를 정의한다고 표현

- 변수는 반드시 타입을 정의해줘야 한다. (바이트 확보 때문)
  - char a;
  - int age;
  - double rate;
  - std::string name;ss

- 변수를 정의하면서 초기값을 설정하는 것을 초기화라고 한다.
  - char a = 10;
  - int age = 21;
  - double rate = 0.85;s
  - std::string name = "abc"
