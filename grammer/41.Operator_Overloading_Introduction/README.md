### 연산자 오버로딩 

- - +,=,* 등등의 연산자를 유저 정의 타입(ex. 클래스)에 대해서도 사용할 수 있도록 하는 기능
- 유저 정의 타입을 기본 타입(int, float, etc)과 유사하게 동작하게 할 수 있다.
-  코드를 보다 이해하기 쉽고, 작성하기 쉽게 만든다.
	- 항상 좋은 것은 아니다. 직관성과 가독성을 높인다고 생각이 들 경우 활용
- 대입 연산자를 제외하면 자동 생성되지 않으며, 사용자가 구현해줘야 한다.

### 예시
```cpp
#include <iostream>

class Point {
public:
	int x, y;
	Point(int x, int y) : x(x), y(y) {}
	// + 연산자 오버로딩
	Point operator+(const Point& other) {
		return Point(x + other.x, y + other.y);
	}
};

int main() {
	Point p1(1, 2);
	Point p2(3, 4);
	Point p3 = p1 + p2; // + 연산자 사용
	std::cout << "p3: (" << p3.x << ", " << p3.y << ")" << std::endl; // p3: (4, 6)
	return 0;
}
```

- 연산자 오버로딩, 기본 규칙
	- 연산의 우선순위를 바꿀 수는 없음(*는 +보다 먼저 계산)
	- 단항, 이항, 삼항 연산의 교체는 불가능
	- 기본 타입(int, float, etc)에 대한 연산자는 오버로딩 불가능
	- 새로운 연산자의 정의 불가
- 연산자는 멤버 함수 또는 전역 함수로 오버로딩 가능!
	- 단, [], (), ->, = 등 몇몇 연산자는 멤버 함수로만 오버로딩 가능

- 연산자 오버로딩 목적
	- Point는 기본 자료형이 아닌 사용자 정의 클래스이다.
	- 연산자 오버로딩을 통해 연산자를 통한 객체의 동작 정의