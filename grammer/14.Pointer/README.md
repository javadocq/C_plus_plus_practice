### Pointer

- 메모리
  - 스택 메모리는 빠르지만 작고, 메모리가 자동으로 정리(해제)된다.
  - 힙 메모리는 크지만 느리고, 메모리를 직접 해제해주어야 한다.

https://i.sstatic.net/P56ru.jpg

// 참고 : https://stackoverflow.com/questions/10057443/explain-the-concept-of-a-stack-frame-in-a-nutshell

- 포인터 변수는 변수의 타입 중 하나
  - 포인터 변수의 값은 메모리의 주소(memory address)
    -> 지금까지 사용한 변수와 포인터 변수와의 차이; 값을 저장하는지, 주소를 저장하는지
  - 포인터는 가리키는 주소에 저장된 데이터의 타입을 알아야 한다.

- 포인터를 쓰는 이유
  - 동적 할당을 통해 힙 영역의 메모리를 사용
  - 변수의 범위 문제로 접근할 수 없는 곳의 데이터를 사용(참조자와 유사한 목적)
  - 배열의 효율적인 사용
  - 다형성은 포인터를 기반으로 구현된다.
  - 시스템 응용 프로그램 / 임베디드 프로그래밍에서는 메모리에 직접 접근이 필요하다.

- 포인터의 정의 및 초기화
  - 기존 변수 타입 뒤에 "_"를 붙여 포인터 변수 정의
    -> "int_"까지 붙여서 사용

    `type* pointer_name = nullptr;`

    ex: int* int ptr;
    double* double ptr = nullptr;

* 초기화를 하지 않으면 쓰레기 값이 들어있는 상태이므로 방지가 필요하다.
* nullptr은 "nowhere" 개념
  -> 임의의 메모리 주소를 가리키고 있는 상태가 아니라, 아무것도 가리키지 않는 상태를 의미, Nullptrd 습관을 들여놓는 게 좋다.

### Accessing Pointer Address

- 변수의 주소값 얻어오기
  - 포인터 변수는 주소값을 저장하므로, 주소값을 얻어올 수 있어야 한다.
  - 이를 위해 주소 연산자("&")를 사용
    -> 연산자가 적용되는 피연산자의 주소값이 반환된다.
    -> 피연산자는 주소값을 얻을 수 있는 종류여야한다.(l-value)
    ex:
    ```
        int num = 10;
        cout << &num << endl; // 0x61ff1c
        cout << &10 << endl; // ERROR, 상수는 주소가 없다.
    ```

- 주소값의 이해
  - "포인터 변수의 크기"와 "포인터가 가리키고 있는 대상의 크기"는 별개이다.
  - 포인터 변수들은 모두 같은 크기
    -> x86에서는 4바이트, x64에서는 8바이트
    -> 포인터는 "주소값을 저장하기 떄문이다.
  - 타입은 왜 필요할까?
    -> 해당 주소의 값에 접근할 때 몇 바이트 크기인지 알아야 하기 떄문이다.
