### Shallow vs Deep Copy

- 얕은 복사의 문제
  - 포인터가 가리키는 데이터가 아닌 포인터 주소값의 복사!
  - 예를 들어 힙 메모리에 int를 할당, 이후 함수를 호출하고 포인터(주소)를 넘겨주면 그 함수의 스택 메모리에 주소가 가진 게 할당된다.
    하지만, 그 스택 메모리가 사라지면서 소멸자가 호출되는데 만약, 소멸자에 delete 주소값이 실행이 된다면 메모리 해제가 된다.
    이후, 메인 함수 스택이 끝나면서 소멸자가 또 호출되는데 이미 해제되었는데 또 해제하려고 하니 에러가 난다.

- 깊은 복사
  - 포인터 주소를 복사하는 것이 아니라, 데이터를 복사하여 복사 생성
  - 복사 생성자가 새로운 힙 공간을 할당하여 동일한 데이터 생성
  - 이중 해제의 문제 해결

  ```
  Deep::Deep(const Deep & source)
  {
      data = new int;
      *data = *source.data;
      cout << "Copy Constructor, deep" << endl;
  }
  ```

- 복사 생성자 잘 사용하는 법
  - 포인터 타입의 멤버 변수가 존재할 때는 (깊은) 복사 생성자 직접 구현
    -> 새로운 heap 공간을 할당하여 값을 복사해 두어야 한다는 것을 명심
  - STL / smart pointer 사용
    -> STL은 내부적으로 안전한 복사 생성자가 구현되어 있다.
    -> Smart pointer는 복사를 허용하지 않거나 참조되어 있는 동안은 해제하지 않는다(shared)
