### 참조자

- 변수의 설명
- 참조자는 (새로운) 변수가 아니다.
- 선언과 동시에 초기화 되어야 한다 (Null 불가능)
- 한 번 초기화되면, 다른 변수의 참조자가 될 수 없다. (int\* const pointer 같은 느낌)
- Const Pointer이면서, 사용 시 자동으로 역참조를 수행하는 개념
- 함수의 매개변수로서 자주 사용

- int&, float& 등 변수 정의시에 &를 붙인 타입을 사용
- 포인터와 마찬가지로, 동일한 타입에 대해서만 참조자 생성 가능
- 참조자를 사용할 때는 마치 a인 것처럼 그냥 사용한다.

살짝 개량형 포인터

- 이때, 참조자인 b는 주소값이 따로 없다.

- Copy가 필요한 경우가 아니라면, const &를 쓰는 것이 기본
  -> Const & rvalue 전달 가능

- 아래 코드는 모두 a의 값인 5를 그대로 출력함
  -> 네개의 Print함수의 장단점은?

  ```
  void PrintConstRef(cosnt int& val) {
      cout << val << endl;
  }
  void PrintAddress(int* valPtr) {
      cout << *valPtr << endl;
  }
  void PrintRef(int& val) {
      cout << val << endl;
  }
  void PrintVal(int val) {
      cout << val << endl;
  }
  int main() {
      int a = 5;
      PrintVal(a);
      PrintRef(a);
      PrintConstRef(a);
      PrintAddress(&a);

      return 0;
  }
  ```

### 🛠️ C++ 함수 매개변수 전달 방식 비교

| 방식                                | 특징            | 장점                                                             | 단점                                                                            |
| :---------------------------------- | :-------------- | :--------------------------------------------------------------- | :------------------------------------------------------------------------------ |
| **`PrintVal(int val)`**             | **값 복사**     | 원본(`a`)을 절대 건드릴 수 없어 안전함. 가장 직관적임.           | 데이터가 크면 복사 비용이 발생함. (예: 1GB짜리 구조체라면 1GB를 또 만듦)        |
| **`PrintRef(int& val)`**            | **참조 (별명)** | 복사 없이 원본 주소로 바로 접근함. 속도가 빠름.                  | 함수 안에서 `val = 10;` 하면 **원본 `a`가 바뀌어버림.** (의도치 않은 수정 위험) |
| **`PrintConstRef(const int& val)`** | **상수 참조**   | **가장 권장됨.** 복사 비용이 없고, `const`라 원본 수정도 방지함. | 딱히 없음. (값을 읽기만 하는 함수라면 **C++의 표준**)                           |
| **`PrintAddress(int* valPtr)`**     | **포인터**      | 원본 주소를 직접 다룸. `nullptr`을 넘길 수 있어 유연함.          | 코드가 복잡해짐(`*`, `&` 기호). `nullptr` 체크 안 하면 프로그램이 터짐.         |

- 참조자가 새로운 변수가 아니라는 뜻의 의미
  - 메모리 디버깅을 통해 a의 주소와 b의 주소를 살펴보면 동일한 것을 알 수 있음
  - 즉, b가 (포인터와는 달리) 메모리 공간을 차지하는 새로운 변수는 아니라는 의미
  - (컴파일 시에 참조자는 가리키는 원본의 메모리 주소로 대체되는 방식)

### l-values and r-values

- 기본적으로는 L-value인 경우에만 참조자를 만들 수 있으나
  -> Const reference인 경우와 R-value reference에 대한 문법이 존재한다.

  ```
  int x = 100;

  int& ref1 = x;
  ref1 = 200;

  int& ref2 = 100; // ERROR
  const int& ref3 = 100; // allowed
  int&& ref4 = 100; // allowed, r-value reference, 이렇게 쓰면, 원래는 그 줄에서 사라졌어야 할 숫자 100이 ref4라는 이름을 얻고 메모리에 정식으로 거주하게 됩니다.
  ```

예를 들어볼게요:

어떤 함수가 아주 거대한 1GB짜리 배열을 임시로 만들어서 반환합니다.

이걸 그냥 복사하면 또 1GB를 복사하느라 시간이 오래 걸리겠죠?

이때 &&를 쓰면, **"어차피 금방 사라질 임시 배열(R-value)인데, 복사하지 말고 내가 그 주소를 통째로 뺏어올게!"**가 가능해집니다.
